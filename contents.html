<h1>Treniformis</h1>
<a name="contents">
  <h2>Contents</h2>
</a>
<ul>
<li>GFW</li>
<ul></ul>
<ul>
  <li>
    <a href="#link-1">ACTIVE_MMSI</a>
  </li>
  <ul>
    <li>2012</li>
    <li>2013</li>
    <li>2014</li>
    <li>2015</li>
    <li>2016</li>
  </ul>
  <li>FINE_LABELS</li>
  <ul>
    <li>2012</li>
    <li>2013</li>
    <li>2014</li>
    <li>2015</li>
    <li>2016</li>
    <li>ALL_YEARS</li>
  </ul>
  <li>FISHING_MMSI</li>
  <ul></ul>
  <ul>
    <li>
      <a href="#link-4">KNOWN</a>
    </li>
    <ul>
      <li>2014</li>
      <li>2015</li>
    </ul>
    <li>KNOWN_AND_LIKELY</li>
    <ul>
      <li>2012</li>
      <li>2013</li>
      <li>2014</li>
      <li>2015</li>
      <li>2016</li>
    </ul>
    <li>
      <a href="#link-6">LIKELY</a>
    </li>
    <ul>
      <li>2012</li>
      <li>2013</li>
      <li>2014</li>
      <li>2015</li>
      <li>2016</li>
    </ul>
  </ul>
  <li>
    <a href="#link-7">SPOOFING_MMSI</a>
  </li>
  <ul>
    <li>2012</li>
    <li>2013</li>
    <li>2014</li>
    <li>2015</li>
    <li>2016</li>
  </ul>
  <li>
    <a href="#link-8">VESSEL_INFO</a>
  </li>
  <ul>
    <li>REEFERS</li>
  </ul>
</ul>
<h2>READMEs</h2>
<a name="link-1">
  <h3>ACTIVE_MMSI <a href="#contents">[toc]</a></h3>
  <pre>Active MMSIs
============

MMSIs of vessels which are broadcasting during the specified period.  Only
MMSIs with a minimum number of positional reports are included.


Migration
---------

Files that were deleted during the migration from `vessel-lists`, but whose
content needs to be preserved.

### active-mmsis-v1.sql ###

```sql
SELECT
  mmsi
FROM
(
  SELECT
    mmsi, count(*) as c_pos
  FROM (TABLE_DATE_RANGE([pipeline_normalize.], TIMESTAMP('{{START_DATE}}'), TIMESTAMP('{{END_DATE}}')))
  WHERE
    lat IS NOT NULL AND lon IS NOT NULL
  GROUP BY
    mmsi
  HAVING
    c_pos &gt; 1000
)
```

### export.sh ###

```bash
#!/bin/bash

PROJECT=world-fishing-827


DATE_RANGES=( \
  "2012-01-01 2013-01-01"  \
  "2013-01-01 2014-01-01"  \
  "2014-01-01 2015-01-01"  \
  "2015-01-01 2016-01-01"  \
  "2016-01-01 2016-06-01"  \
)
QUERY_TEMPLATE=$(cat active-mmsis-v1.sql)

echo "This may take a while, so be patient..."

for RANGE in "${DATE_RANGES[@]}"
do
  read -a DATES &lt;&lt;&lt;"$RANGE"

  QUERY=${QUERY_TEMPLATE//'{{START_DATE}}'/${DATES[0]}}
  QUERY=${QUERY//'{{END_DATE}}'/${DATES[1]}}
  YEAR=${DATES[0]:0:4}
  echo "  ${YEAR}"
  echo ${QUERY} | bq --project=${PROJECT} -q query --format=csv --max_rows 1000000 | tail -n +2 &gt; active-mmsis-${YEAR}-v1.txt
done

echo "Done."
```
</pre>
</a>
<a name="link-4">
  <h3>KNOWN <a href="#contents">[toc]</a></h3>
  <pre># Known Fishing Vessels Version 1

List of MMSIs that are known to be fishing vessels based on the presence of the MMSI on one or more 
public registries.


Migration
---------

Files that were deleted during the migration from `vessel-lists`, but whose
content needs to be preserved.

### export.sh ###

```bash
#!/bin/bash

echo "Exporting Known Fishing MMSIs for 2014..."
cat known-fishing-2014-v1.sql \
  | bq --project=world-fishing-827 -q query --format=csv --max_rows 100000 \
  | tail -n +2 \
  &gt; known-fishing-2014-v1.txt

echo "Exporting Known Fishing MMSIs for 2015..."
cat known-fishing-2015-v1.sql \
  | bq --project=world-fishing-827 -q query --format=csv --max_rows 100000 \
  | tail -n +2 \
  &gt; known-fishing-2015-v1.txt
```

### known-fishing-2014-v1.sql ###

```sql
SELECT
  mmsi
FROM (
  SELECT
    mmsi,
    shipname,
    callsign,
    '' AS imo,
    Registration_Nbr AS national_id,
    'EU' AS source
  FROM
    [EU_match_results.EU_v2]),
  (
  SELECT
    ffa_mmsi AS mmsi,
    shipname,
    callsign,
    STRING(imo) AS imo,
    national_id,
    'FFA' AS source
  FROM
    [Registry_matching_sources.FFA_11_30_2015]
  WHERE
    ffa_mmsi IS NOT NULL
    AND ffa_VESSEL_TYPE NOT IN ('Bunker',
      'Fish Carrier',
      'Mothership')),
  (
  SELECT
    mmsi,
    shipname,
    callsign,
    STRING(imo) AS imo,
    '' AS national_id,
    'CLAV' AS source
  FROM
    [CLAV_match_results.v7_results]
  WHERE
    shiptype_fishing = 1 ),
  (
  SELECT
    mmsi,
    shipname,
    callsign,
    imo,
    '' AS national_id,
    'CCAMLR' AS source
  FROM
    [Registry_matching_sources.CCAMLR_July_2015_with_mmsi])
  where
    mmsi &gt; 100000
    and mmsi not in (100000000,111111110,111111111,124345678,123456789, 222222222, 999999999) //likely spoofing
    and mmsi not in (987357573,987357579,987357559,986737000,983712160,987357529) // helicopters
    and RIGHT(STRING(mmsi), 6) != '000000' //likely spoofing
ORDER BY
  mmsi ASC
```

### known-fishing-2015-v1.txt ###

```sql
SELECT
  mmsi
FROM (
  SELECT
    mmsi,
    shipname,
    callsign,
    '' AS imo,
    national_id,
    'ITU' AS source
  FROM
    [Registry_matching_sources.ITU_Dec_2015_Fishing]),
  (
  SELECT
    mmsi,
    shipname,
    callsign,
    '' AS imo,
    Registration_Nbr AS national_id,
    'EU' AS source
  FROM
    [EU_match_results.EU_v2]),
  (
  SELECT
    ffa_mmsi AS mmsi,
    shipname,
    callsign,
    STRING(imo) AS imo,
    national_id,
    'FFA' AS source
  FROM
    [Registry_matching_sources.FFA_11_30_2015]
  WHERE
    ffa_mmsi IS NOT NULL
    AND ffa_VESSEL_TYPE NOT IN ('Bunker',
      'Fish Carrier',
      'Mothership')),
  (
  SELECT
    mmsi,
    shipname,
    callsign,
    STRING(imo) AS imo,
    '' AS national_id,
    'CLAV' AS source
  FROM
    [CLAV_match_results.v7_results]
  WHERE
    shiptype_fishing = 1 ),
  (
  SELECT
    mmsi,
    shipname,
    callsign,
    imo,
    '' AS national_id,
    'CCAMLR' AS source
  FROM
    [Registry_matching_sources.CCAMLR_July_2015_with_mmsi])
  where
    mmsi &gt; 100000
    and mmsi not in (100000000,111111110,111111111,124345678,123456789, 222222222, 999999999) //likely spoofing
    and mmsi not in (987357573,987357579,987357559,986737000,983712160,987357529) // helicopters
    and RIGHT(STRING(mmsi), 6) != '000000' //likely spoofing
ORDER BY
  mmsi ASC
```</pre>
</a>
<a name="link-6">
  <h3>LIKELY <a href="#contents">[toc]</a></h3>
  <pre>Likely Fishing MMSIs version 2
==============================

MMSIs of vessels which declare the vessel type to be 'Fishing' in type 5 or 24 

Based on this query: https://github.com/GlobalFishingWatch/pleuston/issues/28

See the query committed here for the precise definition.  Basically this is
vessels that have &gt; 1000 positional messages in a year and always declare a 
vessel type of 'Fishing'

For Reference
-------------

### Some stuff form Bjorn via slack ###

https://globalfishingwatch.slack.com/files/bjorn/F1F3WFX9S/2015_likely_fishing_list_query.sql

https://globalfishingwatch.slack.com/files/bjorn/F1F2U7F2P/2015_known_fishing.sql

https://globalfishingwatch.slack.com/archives/identity-matching/p1465393952000011


### Other stuff ###

https://github.com/GlobalFishingWatch/pleuston/issues/27

https://github.com/GlobalFishingWatch/vessel-lists/issues/16

https://github.com/SkyTruth/Benthos/issues/390


### Google Docs ###

https://docs.google.com/document/d/1QnhgyQ3jtGF83a5-4j25hsvPkh6JNT8vGi8ftWx1UUY/edit

https://docs.google.com/spreadsheets/d/12OVeOxg9N1NViKxH4B7nW31-MwAHW_mS3zPBe2kfIuQ/edit#gid=0


Migration
---------

Files that were deleted during the migration from `vessel-lists`, but whose
content needs to be preserved.


### likely-fishing-v2.sql ### 

```sql
select a.mmsi as mmsi from
(
  SELECT
    mmsi,
    count(*) c_msg,
    sum (shiptype_text = 'Fishing') c_fishing,
    sum (shiptype_text = 'Fishing') / count(*) fishing_msg_ratio
  FROM (TABLE_DATE_RANGE([pipeline_normalize.], TIMESTAMP('{{START_DATE}}'), TIMESTAMP('{{END_DATE}}')))
  WHERE
    type in (5, 24)
    and shiptype_text is not null
    and shiptype_text != 'Not available'
  GROUP EACH BY
    mmsi
  HAVING
    c_fishing &gt; 10 and fishing_msg_ratio = 1.0
) a
JOIN EACH
(
  SELECT
    integer(mmsi) as mmsi, COUNT(*) AS c_pos
  FROM (TABLE_DATE_RANGE([pipeline_normalize.], TIMESTAMP('{{START_DATE}}'), TIMESTAMP('{{END_DATE}}')))
  WHERE
    lat IS NOT NULL AND lon IS NOT NULL
  GROUP BY
    mmsi
  HAVING
    c_pos &gt; 1000
)b
ON a.mmsi = b.mmsi
```


### test_query.sql ###

```sql
  SELECT
    mmsi
  FROM (TABLE_DATE_RANGE([pipeline_normalize.], TIMESTAMP('{{START_DATE}}'), TIMESTAMP('{{END_DATE}}')))
  group by mmsi
  limit 100000
```


### export.sh ###

```bash
#!/bin/bash

PROJECT=world-fishing-827


DATE_RANGES=( \
  "2012-01-01 2013-01-01"  \
  "2013-01-01 2014-01-01"  \
  "2014-01-01 2015-01-01"  \
  "2015-01-01 2016-01-01"  \
  "2016-01-01 2016-06-01"  \
)
QUERY_TEMPLATE=$(cat likely-fishing-v2.sql)


#DATE_RANGES=( \
#  "2015-01-01 2016-01-01"  \
#)
#QUERY_TEMPLATE=$(cat test_query.sql)


echo "This may take a while, so be patient..."

for RANGE in "${DATE_RANGES[@]}"
do
  read -a DATES &lt;&lt;&lt;"$RANGE"

  QUERY=${QUERY_TEMPLATE//'{{START_DATE}}'/${DATES[0]}}
  QUERY=${QUERY//'{{END_DATE}}'/${DATES[1]}}
  YEAR=${DATES[0]:0:4}
  echo "  ${YEAR}"
  echo ${QUERY} | bq --project=${PROJECT} -q query --format=csv --max_rows 100000 | tail -n +2 &gt; likely-fishing-${YEAR}-v2.txt
done

echo "Done."
```</pre>
</a>
<a name="link-7">
  <h3>SPOOFING_MMSI <a href="#contents">[toc]</a></h3>
  <pre># Spoofing MMSI Version 3

List of MMSIs that experience substantial ID spoofing

By ID spoofing, we mean two or more vessels that are using the same MMSI at the same time. 

All the messages for an MMSI are grouped into sets of tracks that are contiguous spatially and temporally.  
Each continuous track has a unique seg_id field added.  Some tracks contain invalid lan/lon (like 91, 181) and 
are put into a special 'BAD' segment. 

The test for spoofing is fairly naive - we simple compute the extent of each segment in time, add them all up, 
and compare that to the extent of time that the vessel is active.  If the segment time is longer than the 
active time, then we know that some of the segments must overlap, and this is the indication of ID spoofing.


Migration
---------

Files that were deleted during the migration from `vessel-lists`, but whose
content needs to be preserved.


### spoofing-mmsis-v3.sql ###

```sql
select mmsi from
(
SELECT
  a.mmsi AS mmsi,
  active_days,
  message_count,
  total_days,
  segment_count,
  segment_days,
  segment_days / LEAST(total_days, float(active_days)) AS spoof_ratio,
  segment_days - LEAST(total_days, float(active_days)) AS overlap_days,
  (segment_days - LEAST(total_days, float(active_days))) / LEAST(total_days, float(active_days)) AS spoof_percent,
  (segment_days / LEAST(total_days, float(active_days))) * (segment_days - LEAST(total_days, float(active_days))) as spoof_factor
FROM (
  SELECT
    mmsi,
    COUNT(*) AS active_days,
    SUM(message_count) AS message_count,
    (MAX(max_timestamp) - MIN(min_timestamp)) / 86400 AS total_days
  FROM (
    SELECT
      mmsi,
      UTC_USEC_TO_DAY(timestamp) AS day,
      COUNT(*) message_count,
      MIN(TIMESTAMP_TO_SEC(timestamp)) AS min_timestamp,
      MAX(TIMESTAMP_TO_SEC(timestamp)) AS max_timestamp
    FROM (TABLE_DATE_RANGE([pipeline_classify_logistic_661b.], TIMESTAMP('2015-01-01'), TIMESTAMP('2015-12-31')))
    WHERE
      RIGHT(seg_id, 3) != 'BAD'
    GROUP BY
      mmsi,
      day )
  GROUP BY
    mmsi ) a
JOIN (
  SELECT
    mmsi,
    COUNT(*) segment_count,
    SUM(max_timestamp - min_timestamp) / 86400 AS segment_days
  FROM (
    SELECT
      mmsi,
      COUNT(*) AS message_count,
      MIN(TIMESTAMP_TO_SEC(timestamp)) AS min_timestamp,
      MAX(TIMESTAMP_TO_SEC(timestamp)) AS max_timestamp
    FROM (TABLE_DATE_RANGE([pipeline_classify_logistic_661b.], TIMESTAMP('2015-01-01'), TIMESTAMP('2015-12-31')))
    WHERE
      RIGHT(seg_id, 3) != 'BAD'
    GROUP BY
      mmsi,
      seg_id )
  GROUP BY
    mmsi ) b
ON
  a.mmsi = b.mmsi
)
where active_days &gt; 3 and spoof_percent &gt; 0.01
```</pre>
</a>
<a name="link-8">
  <h3>VESSEL_INFO <a href="#contents">[toc]</a></h3>
  <pre>
REEFERS.csv
===========

Fields:

1. mmsi: MMSI
2. imo: IMO (if available)
3. call_sign: vessel callsign
4. width: width of vessel
5. avg_length: average vessel total overall length (LOA) in meters
6. stddev_length: standard deviation of vessel length, meters
7. num_length_sources: number values used to calculate avg and std dev of length
8. avg_gross_tonnage: average vessel gross tonnage
9. stddev_gross_tonnage: standard deviation of gross tonnage (tons)
10. num_gross_tonnage_sources: number of values used to calculate avg and std dev of tonnage
11. dead_weight: vessel deadweight (tons)
12. source: where information from vessel was obtained:

    - CLAV = CLAV registry list (from BQ)
    - ITU = ITU registry list (from BQ)
    - ICCAT = ICCAT registry (Dahlhousie students)
    - WCPFC = Western and Central Pacific Tuna Commision registry
    - FFA = FFA registry (from BQ)
    - CCSBT = CCSBT registries (Dahlhousie students)
    - encounters = vessels identified from encounters, information from MarineTraffic
            
13. flag_state: flag state of vessel (from MID codes)</pre>
</a>